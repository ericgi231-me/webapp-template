name: Deploy Web Application
description: Build images -> Copy to server -> Deploy with Docker Compose (This workflow can be deleted in real apps)
run-name: Deploying ${{ github.sha }} to production
on:
  workflow_call:
    inputs:
      app_name:
        description: 'Name of the application'
        required: true
        type: string
      public_port:
        description: 'Public port to reach apps router' # TODO: Gracefully handle public port collisions
        required: true
        type: string
      node_env:
        description: 'Node environment'
        required: false
        type: string
        default: 'production'
    secrets:
      SSH_PRIVATE_KEY:
        required: true
      SERVER_HOST:
        required: true
      SERVER_USER:
        required: true
      DATABASE_PASSWORD:
        required: false

env:
  # Images
  FRONTEND_IMAGE_NAME: ghcr.io/${{ github.repository_owner }}/${{ inputs.app_name }}-frontend
  BACKEND_IMAGE_NAME: ghcr.io/${{ github.repository_owner }}/${{ inputs.app_name }}-backend
  # Database
  DATABASE_NAME: ${{ inputs.app_name }}-db
  DATABASE_USER: ${{ inputs.app_name }}-user
  DATABASE_PASSWORD: ${{ secrets.DATABASE_PASSWORD || '' }}
  DATABASE_VOLUME: ${{ inputs.app_name }}-db-volume
  # Server info
  SERVER_HOST: ${{ secrets.SERVER_HOST }}
  SERVER_USER: ${{ secrets.SERVER_USER }}
  SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v5

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: List all files
        run: ls -R

      - name: Build Docker images
        run: |
          IMAGES_TO_SAVE=""
          
          # Build frontend if directory exists and port is configured
          if [ -d "./packages/frontend" ]; then
            echo "Building frontend image..."
            docker build \
              -t ${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }} \
              -f ./packages/frontend/Dockerfile \
              --build-arg APP_NAME=${{ inputs.app_name }} .
            docker tag ${{ env.FRONTEND_IMAGE_NAME }}:${{ github.sha }} ${{ env.FRONTEND_IMAGE_NAME }}:latest
            IMAGES_TO_SAVE="$IMAGES_TO_SAVE ${{ env.FRONTEND_IMAGE_NAME }}:latest"
          fi
          
          # Build backend if directory exists and port is configured
          if [ -d "./packages/backend" ]; then
            echo "Building backend image..."
            docker build \
              -t ${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }} \
              -f ./packages/backend/Dockerfile \
              --build-arg APP_NAME=${{ inputs.app_name }} .
            docker tag ${{ env.BACKEND_IMAGE_NAME }}:${{ github.sha }} ${{ env.BACKEND_IMAGE_NAME }}:latest
            IMAGES_TO_SAVE="$IMAGES_TO_SAVE ${{ env.BACKEND_IMAGE_NAME }}:latest"
          fi
          
          # Save all built images
          if [ ! -z "$IMAGES_TO_SAVE" ]; then
            docker save $IMAGES_TO_SAVE | gzip > app-images.tar.gz
          else
            echo "No images to build - creating empty archive"
            tar -czf app-images.tar.gz --files-from /dev/null
          fi

      - name: Test SSH connection
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SSH_PRIVATE_KEY }}
          port: 22
          script: |
            echo "SSH connection successful!"
            whoami
            pwd
            ls -la /var/www/
          
      - name: Copy files to prod server
        uses: appleboy/scp-action@v1.0.0
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SSH_PRIVATE_KEY }}
          port: 22
          source: "app-images.tar.gz,docker-compose.yml"
          target: "/var/www/${{ inputs.app_name }}/"

      - name: Deploy on prod server
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SSH_PRIVATE_KEY }}
          port: 22
          script: |
            cd /var/www/${{ inputs.app_name }}
            
            # Create .env file for docker-compose
            cat > .env << EOF
            APP_NAME=${{ inputs.app_name }}
            PUBLIC_PORT=${{ inputs.public_port }}
            FRONTEND_IMAGE_NAME=${{ env.FRONTEND_IMAGE_NAME }}
            BACKEND_IMAGE_NAME=${{ env.BACKEND_IMAGE_NAME }}
            DATABASE_NAME=${{ env.DATABASE_NAME }}
            DATABASE_USER=${{ env.DATABASE_USER }}
            DATABASE_VOLUME=${{ env.DATABASE_VOLUME }}
            NODE_ENV=${{ inputs.node_env }}
            EOF

            export DATABASE_PASSWORD="${{ env.DATABASE_PASSWORD }}"
            
            # Load images if any were built
            if [ -s app-images.tar.gz ]; then
              docker load < app-images.tar.gz
            fi
            
            # Stop existing containers
            docker compose down || true
            
            # Start all services defined in docker-compose.yml
            docker compose up -d
            
            # Clean up old images
            docker image prune -f
            for image in ${{ env.FRONTEND_IMAGE_NAME }} ${{ env.BACKEND_IMAGE_NAME }}; do
              if docker images $image -q 2>/dev/null | head -n 1; then
                docker images $image --format "table {{.Repository}}\t{{.Tag}}\t{{.ID}}" | tail -n +4 | awk '{print $3}' | head -n -3 | xargs -r docker rmi 2>/dev/null || true
              fi
            done
            
            # Clean up deployment files
            rm -f app-images.tar.gz

      - name: Verify deployment
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ env.SERVER_HOST }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SSH_PRIVATE_KEY }}
          port: 22
          script: |
            cd /var/www/${{ env.APP_NAME }}
            echo "Deployment verification complete"