version: "3.8"
services:
  main-nginx:
    image: nginx:alpine
    build: # optional: you can mount or build a custom nginx image
      context: .
      dockerfile: deploy/nginx-main.Dockerfile
    ports:
      - "80:80"                  # only main-nginx binds host :80
    depends_on:
      - app1
      - app2
    volumes:
      - ./deploy/nginx-main.conf:/etc/nginx/conf.d/default.conf:ro
    restart: unless-stopped

  app1:
    build:
      context: .
      dockerfile: packages/app1/Dockerfile   # your app image (static or server)
    environment:
      - PORT=80
    expose:
      - "80"                 # internal service port (for main-nginx to reach)
    ports:
      - "3001:80"            # host:container -> user can connect at mysite.com:3001
    restart: unless-stopped

  app2:
    build:
      context: .
      dockerfile: packages/app2/Dockerfile
    environment:
      - PORT=80
    expose:
      - "80"
    ports:
      - "3002:80"
    restart: unless-stopped

server {
  listen 80;
  server_name _;

  # Root route / serves a main website or index
  location / {
    # Option A: serve main site's static files or pass to a main-site container
    # proxy_pass http://main_site:80;
    # For a simple main site, you might serve static content directly in main-nginx.
    return 200 'Main site: welcome. See /app1 and /app2';
    add_header Content-Type text/plain;
  }

  # App1 under /app1/ - rewrite so app1 receives paths without /app1 prefix
  location /app1/ {
    rewrite ^/app1/(.*)$ /$1 break;
    proxy_pass http://app1:80;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_buffering off;
  }

  # App2 under /app2/
  location /app2/ {
    rewrite ^/app2/(.*)$ /$1 break;
    proxy_pass http://app2:80;
    proxy_set_header Host $host;
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_buffering off;
  }
}



cd /var/www/${APP_NAME}

# Use compose project isolation and the given images (set in .env)
docker compose -p "${APP_NAME}" pull || true   # pull is no-op if images loaded via docker load

# Bring up the stack
docker compose -p "${APP_NAME}" up -d

# Verify frontend using compose-provided container IDs
FRONTEND_CIDS=$(docker compose -p "${APP_NAME}" ps -q frontend)
if [ -z "$FRONTEND_CIDS" ]; then
  echo "No frontend containers running"
  docker compose -p "${APP_NAME}" ps
  docker compose -p "${APP_NAME}" logs --no-color frontend --tail 100
  exit 2
fi

# Prefer docker HEALTHCHECK if available
for CID in $FRONTEND_CIDS; do
  HS=$(docker inspect --format '{{.State.Health.Status}}' "$CID" 2>/dev/null || true)
  if [ -n "$HS" ]; then
    echo "Frontend $CID health=$HS"
    if [ "$HS" != "healthy" ]; then
      echo "Frontend container not healthy"
      docker compose -p "${APP_NAME}" logs --no-color frontend --tail 100
      exit 3
    fi
  else
    # Fallback to testing the published port
    if [ ! -z "${FRONTEND_PORT}" ]; then
      sleep 3
      if ! curl -fS --max-time 5 "http://localhost:${FRONTEND_PORT}/" >/dev/null 2>&1; then
        echo "Frontend not responding on ${FRONTEND_PORT}"
        docker compose -p "${APP_NAME}" logs --no-color frontend --tail 100
        exit 4
      fi
    fi
  fi
done
echo "Frontend OK"